//
//  ModelObject.swift
//  RESS
//
//  Created by Luiz Fernando Silva on 17/07/15.
//  Copyright (c) 2015 Luiz Fernando Silva. All rights reserved.
//

import Foundation
import SwiftyJSON

// MARK: - ModelObject -

/// Protocol to be implemented by objects that can be mapped from and to JSON objects
protocol ModelObject: JsonInitializable, JsonSerializable, Equatable {
    
    /// Returns whether this object is equal to another, same model object of the same type, value-wise.
    /// The default implementation calls .serialize() on self and other, and compare the results for equality
    /// according to the rules of JSON equality from the SwiftyJSON implementation
    func equalsTo(_ other: Self) -> Bool
}

extension ModelObject {
    func equalsTo(_ other: Self) -> Bool {
        return jsonEquals(lhs: self, rhs: other)
    }
}

func ==<T: ModelObject>(lhs: T, rhs: T) -> Bool {
    return lhs.equalsTo(rhs)
}

func ==<T: ModelObject>(lhs: T, rhs: T) -> Bool where T: AnyObject {
    // Both objects are the same object - return true always
    if(lhs === rhs) {
        return true
    }
    return lhs.equalsTo(rhs)
}


// MARK: - Json interaction -

/// Protocol to be implemented by types that can be initialzed with a JSON object
protocol JsonInitializable {
    init(json: JSON) throws
}

/// Protocol to be implemented by types that can be serialized into a JSON object
protocol JsonSerializable {
    
    /// Serializes this object into a dictionary
    func serialize() -> JSON
}

/// Returns true if the json generated by both JSON serializable objects match; false otherwise
func jsonEquals<T: JsonSerializable>(lhs: T, rhs: T) -> Bool {
    return lhs.serialize() == rhs.serialize()
}

// MARK: - Miscelaneous

/**
 Miscelaneous extension to Dictionary used to map String-valued enum/AnyObject pairs into JSON objects.
 This encourages behaviour of creating JSONs using strongly-typed keys via enums and maping them into JSON objects
 e.g.:

 enum JsonKey: String {
    case id = "id"
    case name = "name"
 }
 
 var dict = [JsonKey.id: 10, JsonKey.name: "George"]
 var json = dict.mapToJSON()
*/
extension Dictionary where Key: RawRepresentable, Value: Any, Key.RawValue == String {
    /// Maps this dictionary to a flat JSON object
    func mapToJSON() -> JSON {
        var dict: [String: Any] = [:]
        
        self.forEach { dict[$0.rawValue] = $1 }
        
        return JSON(dict)
    }
}
